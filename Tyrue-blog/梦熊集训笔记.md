## [Broad](https://trello.com/b/y0tgN6vd/%E6%A2%A6%E7%86%8A%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD)

# NOIP十三连测 #1

### Day1-T1

![img](https://img2023.cnblogs.com/blog/2659912/202407/2659912-20240708162856334-163964290.png)

将原题意转化为两点形成的三角形夹角为 $\theta$ 且 $\sin\theta+\cos\theta$ 最小

考虑此值最大为 $\theta=\frac{\pi}{4}$ 时最大，所以我们需要两点连线尽可能的靠近 $\frac{\pi}{4}$ 线，考虑将坐标系向左旋转 $\frac{\pi}{4}$ ，然后按照转后横坐标坐标排序，考虑此时相邻两点一定是原图中连线最接近 $\frac{\pi}{4}$ 线的

这是一种情况，另一种情况是 $\frac{3\pi}{4}$ 线，同样的按照转后纵坐标排序即可

# 暑假集训

## 7.16

### T1 : CF425E

## 7.18

怎么这场比赛每个题都想了点出来

### card

此题读错题导致爆零，警钟长鸣

我们考虑合并两个字符串 $s_1,s_2$ 时，假设 $s1$ 在前，怎样才能合法

一定是 $s_1$ 的最长全零后缀长度 $suf_1$ 和 $s_2$ 的全零前缀 $pre_2$ 满足 $suf_1+pre_2=m-1$ 才可以合并

有了这个观察我们就可以考虑怎样转化问题，我们可以将这种关系连成边，满足题目关系的情况就是需要遍历没有一条遍，并且尽可能的走编号较小的边

判断一下无解情况，然后把每个点的连边序号从小到大排序，跑欧拉回路就好了

### dating

先看部分分

`Subtask 1` : 直接枚举值域内所有点一一求距离即可

`Subtask 2` : 考虑所有点都需要计入，我们考虑一个经典结论，分别取 $x,y$ 的中位数

$$\sum_{i=1}^n|x_i-x_0|+|y_i-y_0|$$
$$\sum_{i=1}^n|x_i-x_0|+\sum_{i=1}^n|y_i-y_0|$$
观察到 $x,y$ 的贡献可以分开计算，我们就只需要分别选取 $x,y$ 的中位数即可，之前证过

`Subtask 3` 考虑我们上面求中位数的结论，我们可以发现终点一定是已有点对的一个坐标，我们可以 $O(n^2)$ 枚举终点坐标，然后 $O(n)$ 求取距离，然后求 $k$ 小的过程可以排序 $O(n\log n)$ 或者直接用 `nth_element` 函数 $O(n)$ 求取，总时间复杂度是 $O(n^3)$

`Subtask 4,5` 考虑式子的形式

$$\sum_{i=1}^n|x_i-x_0|+\sum_{i=1}^n|y_i-y_0|$$

我们考虑每一维的变化过程，针对 $y$ 这一维观察，先从大到小排序，我们可以发现我们可以拆成 $\sum_{i=1}^k (y_0-y_i)+\sum_{i=k+1}^n(y_i-y_0)$ 

我们发现如果取中位数的话两端相加是可以将 $y_0$ 消掉的，也就是 $\sum_{i=1}^k-y_i+\sum_{i=k+1}^ny_i$

考虑如果 $x_0$ 当前是确定的，那我们可以 $O(n)$ 计算出 $x$ 这一维的贡献，然后考虑怎样快速求出 $y$ 的 $k$ 小贡献

因为要取中位数，并且对于每一个位置如果选的话就一定会考虑 $x$ 的影响，所以一定是 $\frac{k}{2}$ 个 $|x_0-x_i|-y_i$ 类型的，以及 $\frac{k}{2}$ 个 $|x_0-x_i|+y_i$ 类型的，所以我们考虑从前往后扫一遍 ( $y$ 已经排序 ) ，然后针对每一个位置求出前缀 $\frac{k}{2}$ 个最小的 $|x_0-x_i|-y_i$ 以及后缀 $\frac{2}{k}$ 个 $|x_0-x_i|+y_i$ 

思路已经很明朗了！稍微捋一下

我们先 $O(n)$ 枚举所有 $x$ ，然后针对当前的 $x_i$ 我们 $O(n)$ 求出当前 $x_i$ 的所有贡献，然后我们考虑 $O(n\log n)$ 算出 $y$ 的贡献，用堆实现，求出前缀后缀所有值，然后把对于每一个位置的前缀后缀值合并起来即可

## 7.22

### resource

考场写挂了。。 

考虑我们对于多个相同的数字进行贪心，我们是怎么做？一定是先找 $b_i$ 最大的进行操作，因为如果一个数字现在不操作，下一步就会多操作一次也就多一次贡献，所以大数放在前面一定是不劣的

考虑怎么做，我们针对一种相同的数字进行操作，找出其中 $b_i$ 最大的，计算贡献，然后删除，将当前应该匹配的数字加一，接着进行下一轮匹配，可以用一个大根堆来维护，其中细节特别多，调了好长时间。。感觉也没说清楚

因为如果枚举当前应该匹配的数字是 $O(V)$ 的，但是我们发现可能会有的区间不会有数字匹配，所以我们可以考虑如果当前没有数字匹配直接跳到下一个 $a_i$ 进行匹配，总复杂度是 $O(n\log n)$ 的

### book

考场暴力冲了 `90` 分（

先转化题意，观察到一些信息有关前缀，先往 `trie` 树上思考

对于对于一开始给定的字符串直接插入到 `trie` 树中，先不考虑操作 `1` ，我们发现，操作 `2` 实际上就是对于 `trie` 树上的某个节点进行子树加，操作 `3` 则是进行单点查询

那考虑 `1` 操作该如何维护？我们可以考虑离线先将所有的字符串插入到该插入的位置，然后查询当前时间此位置的答案，然后在后面减掉插入之前的贡献即可

复杂度是 $O(q\log |S|)$

插入字符串的时候要倍增找点

## 8.3

### T2 : Gym104611E

## 8.5

### road

很经典的二分答案，最小 $k$ 使得满足条件

考虑二分 $k$ ，跑最短路，如果两点之间距离小于 $mid$ ，就可以划为 $0$ ，否则就需要在中间加点，最少加 $\lfloor \frac{len}{mid}\rfloor-1$ 个点

计算从起点到终点所花费的最少的点数，如果没超过限制说明还能进一步缩小 $mid$ ，否则就需要扩大

复杂度是 $m^2\log V$ 的， $n^2$ `dij`

### set

考虑把集合 `B` 的依赖关系建成图，是一张有向无环图

因为需要求集合的交集，其实就只有所以被以来的点向根节点公共的一段

考虑把这张图中正确的依赖关系建出来，也就是所有被依赖的点的 `lca` 连边

每次查询集合的并集，就是所有点到根节点的路径并集

但是每次查询的时候只关心几个关键点，需要向虚树那方面考虑

考虑建虚树的过程，按照节点的 `dfn` 排序，然后相邻两个节点的 `lca` 也变为虚树上节点，这个过程用来求路径长也可以直接算出，所有节点到根节点的路径长再减去相邻两个节点的 `lca` 深度